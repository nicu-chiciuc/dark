type AnalyticsAction =
  | ThumbsUp
  | ThumbsDown
  | CodeExecuted of Bool

[<DB("AnalyticsDB")>]
type Analytics =
  { SessionID: Uuid
    DarkPrompt: String
    UserPrompt: String
    GeneratedCode: String

    // We assume it'll be of type AnalyticsAction
    ActionJson: String}

[<HttpHandler("GET", "/api/get-all-analytics")>]
let handler req =
  let allAnalytics = DB.getAll_v3 AnalyticsDB


  let serialized = allAnalytics |> Json.serialize<List<Analytics>>


  match serialized with
  | Ok s -> Http.response (String.toBytes s) 200
  | Error _ -> Http.response "An error occured" 400



[<HttpHandler("GET", "/api/show-handler-req")>]
let handler req =


  Http.response cookies 200





let currentCanvasPath () =
    "/home/dark/app/canvases/nicu-canvas/"

let httpRootPath () =
    currentCanvasPath () ++ "bolero/output/wwwroot/"

let getApiKey () =
  let maybeKey = File.read (currentCanvasPath () ++ "openai-api-key.txt")

  match maybeKey with
  | Ok key -> key |> String.fromBytes
  | Error _ -> ""


let logToFile (contents: String) =
  let filePath = currentCanvasPath () ++ "log.txt"
  let currentTimeStr = DateTime.now |> DateTime.toString

  let result = File.appendText filePath (currentTimeStr ++ "  " ++ contents ++ "\n")

  result

let addAnalytics (action: AnalyticsAction) =
  let currentTimeStr = DateTime.now |> DateTime.toString

  let dbKey = DB.generateKey_v0
  let sessionId = Uuid.generate_v0
  let darkPrompt = "TODO"
  let userPrompt = "TODO"
  let generatedCode = "TODO"
  let actionJson = action |> Json.serialize<AnalyticsAction> |> Result.withDefault_v0 "<failed to stringify action>"

  let analytic = {
    SessionID = sessionId
    DarkPrompt = darkPrompt
    UserPrompt = userPrompt
    GeneratedCode = generatedCode

    ActionJson= actionJson}

  let result = DB.set_v1 analytic dbKey AnalyticsDB

  result





[<HttpHandler("GET", "/")>]
let handler req =
  let body = "hello"
  let path = httpRootPath () ++ "index.html"

  logToFile (path ++ " nice")

  let maybeFile = File.read path

  let file = match maybeFile with
    | Ok file -> file
    | Error -> "File not found"

  Http.responseWithHeaders
    (file)
    (Dict.fromListOverwritingDuplicates [ ("Content-Type", "text/html") ])
    200


[<HttpHandler("GET", "/:someFile")>]
let handler req =
  let path = httpRootPath () ++ someFile

  let newUuid = Uuid.generate_v0

  logToFile "---------"

  logToFile path

  let maybeFile = File.read path

  logToFile "before match"

  let file = match maybeFile with
    | Ok file -> file
    | Error -> "File not found"

  logToFile "after match"

  let arrSplit = String.split_v1 path  "."

  logToFile "after split"

  let fileExtension = match arrSplit  with
    | [ _; ext ] -> ext
    | _ -> ""

  logToFile fileExtension

  let contentType = match fileExtension with
    | "js" -> "text/javascript"
    | "css" -> "text/css"
    | "html" -> "text/html"
    | "dll" -> "application/octet-stream"
    | "wasm" -> "application/wasm"
    | "ico" -> "image/x-icon"
    | _ -> "text/plain"

  logToFile contentType


  Http.responseWithHeaders
    (file)
    (Dict.fromListOverwritingDuplicates [ ("Content-Type", contentType) ])
    200

  let fileBytes = match maybeFile with
    | Ok file -> file
    | Error -> "File not found"

  logToFile "toBytes"


  Http.response fileBytes 200


[<HttpHandler("GET", "/api/get-prompt")>]
let handler req =
  let filePath = currentCanvasPath () ++ "prompt.txt"
  let prompt = File.read filePath

  logToFile "Got prompt"

  addAnalytics ThumbsUp

  let respBody =
    match prompt with
    | Ok p -> p
    | Error _ -> Bytes.empty

  Http.response respBody 200


[<HttpHandler("GET", "/api/save-prompt")>]
let handler req =
  let filePath = currentCanvasPath () ++ "prompt.txt"
  let contents =  request.body
  let result = File.write filePath contents


  // Save to DB


  match result with
  | Ok r ->   Http.response r 200
  | Error e ->  Http.response e 400




type OpenAICompletionRequest = {
  model: String
  max_tokens: Int
  temperature: Float
  prompt : String
}

[<HttpHandler("POST", "/api/gpt4")>]
let _handler _req =
  let _ = "IMPORTAT, remove before commit"
  let apiKey = getApiKey ()

  let reqBody =
    let prompt = request.body |> String.fromBytes
    let serialized =
      { model= "text-davinci-003"
        max_tokens= 300
        temperature= 0.7
        prompt= prompt}
      |> Json.serialize<OpenAICompletionRequest>
    match serialized with
    | Ok r -> r |> String.toBytes
    | Error e -> Bytes.empty

  let headers =
    [
      ("Authorization", "Bearer " ++ apiKey)
      ("Content-Type", "application/json")
    ]

  let response = HttpClient.request "POST" "https://api.openai.com/v1/completions" headers reqBody

  match response with
  | Ok r -> Http.response r.body 200
  | Error e -> Http.response e 400

[<HttpHandler("GET", "/api/envvars")>]
let handler req =
  let files =
    Directory.pwd
    |> Directory.ls
    |> Json.serialize<List<String>>

  let varName = "DOTNET_RUNNING_IN_CONTAINER"

  let _ = "Transofrming to list so that we can serialize it"
  let envsToList = Dict.toList EnvVar.getAll

  let maybeEnvs = Json.serialize<List<Tuple<String, String>>> envsToList
  let maybeEnv = EnvVar.get varName

  let singleEnv = match maybeEnv with
  | Just env -> $"{varName} is {env}"
  | None -> $"{varName} not found"

  let allEnvs = match maybeEnvs with
  | Ok envs -> envs
  | Error -> "An error during retrieval"


  Http.response (String.toBytes allEnvs) 200

